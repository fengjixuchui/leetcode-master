
# 思路 

本题大家多举一个例子，就发现这其实就是斐波那契数列。

题目509. 斐波那契数中的代码初始化部分稍加改动，就可以过了本题。

C++代码如下：
```
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 1) return n;
        vector<int> dp(n + 1);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];

    }
};
```

既然这么简单为什么还要讲呢，其实本题稍加改动就是一道面试好题，如果每次可以爬 1 或 2或3或者m 个台阶呢，走到楼顶有几种方法？ 



* 确定dp数组以及下标的含义

dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法

* 确定递推公式 

dp[i]有几种来源，dp[i - 1]，dp[i - 2]

* dp数组如何初始化
* 确定遍历顺序

dp里求排列，1 2 步  和 2 1 步都是上三个台阶，但不一样！

这是求排列
```
class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= 2; j++) {
                if (i - j >= 0) dp[i] += dp[i - j];
            }
        }
        return dp[n];
    }
};
```

# 总结 

如果我来面试的话，我就会想给候选人出一个 本题原题，看其表现，如果顺利写出来，进而在要求每次可以爬[1 - m]个台阶应该怎么写。

顺便再考察一下两个for循环的嵌套顺序，为什么target放外面，nums放里面。这就能反馈出对背包问题本质的掌握程度，是不是刷题背公式，一眼就看出来。

这么一连套下来，如果候选人都能答出来，相信任何一位面试官都是非常满意的。

**本题代码不长，题目也很普通，当稍稍一进阶就可以考察本质问题，而且题目进阶的内容在leetcode上并没有，一定程度上就可以排除掉刷题党了，简直是面试题目的绝佳选择！**

相信通过这道简单的斐波那契数列题目，大家能感受到大厂面试官最喜欢什么样的面试题目了，并不是手撕红黑树！


所以本题是一道非常好的题目。

