
贪心的本质是选择每一阶段的局部最优，从而达到全局最优。 

这么说有点抽象，来举一个例子：

例如，有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？ 

指定每次拿最大的，最终结果就是拿走最大数额的钱。

每次拿最大的就是局部最优，最后拿走最大数额的钱就是推出全局最优。

在举一个例子如果是 有一堆盒子，你有一个背包体积为n，如何把背包尽可能装满，如果还每次选最大的盒子，一定不行。这时候就需要动态规划。动态规划的问题在下一个系列会详细讲解。


很多同学做贪心的题目的时候，想不出来是贪心，想知道有没有什么套路可以一看看出来是贪心，说实话贪心算法并没有固定的套路。

所以唯一的难点就是如何通过局部最优，推出整体最优。 

那么如何能看出局部最优是否能退出整体最优呢？有没有什么固定策略或者套路呢？

**不好意思，没有！** 靠自己手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可行，可能需要动态规划。

验证可不可以用贪心最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧。

那又有同学认为手动模拟，举例子得出的结论不靠谱，想要严格的数学证明。 

数学证明一般可以是：

* 数学归纳法
* 反证法

看教课书上讲解贪心真的是一堆公式，估计连看都不想看。

所以做了贪心题目的时候大家就会发现，如果啥都要数学证明一下，就是把简单问题搞复杂了。

**面试中基本不会让面试者现场证明贪心的合理性，代码写出来跑过测试用例即可，或者自己能自圆其说就行**。

举一个不太恰当的例子：我要用一下1+1 = 2，但我要先证明1+1 为什么等于2。严谨是严谨了，但没必要。

虽然这个例子有点极端，但可以表达这么个意思：就是手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心。

**例如刚刚举的拿钞票的例子，就是模拟一下每次那做大的，最后就能拿到最多的钱，这还要数学证明的话，其实就不在算法面试的范围内了，可以看看专业的数学书籍！**

所以这也是为什么有的通过AC（accept）了一些贪心的题目，但都不知道自己用了贪心算法，因为贪心有时候就是常识性的推导，所以会认为本就应该这么做！

那么刷题的时候什么时候真的需要数学推导呢？ 

例如环形链表2，这道题目不用数学推导一下，就找不出环的起始位置，想试一下就不知道怎么试，这种题目确实需要数学简单推导一下。

**但贪心问题就不必了，模拟一下感觉是这么回事，就迅速试一试**。


贪心算法求解步骤：

* 将问题分解为若干个子问题
* 找出适合的贪心策略
* 求解每一个子问题的最优解
* 将局部最优解堆叠成全局最优解


当前子问题的最优解

一个子问题的最优解会是下一个子问题最优解的一部分，重复这个操作直到堆叠出该问题的最优解 

贪心算法最关键的部分在于贪心策略的选择，贪心选择的意思是对于所求问题的整体最优解可以通过一系列的局部最优选择求得。

而必须注意的是，贪心选择必须具备无后效性，也就是某个状态不会影响之前求得的局部最优解。


贪心算法的应用
对数据压缩编码的霍夫曼编码（Huffman Coding）
求最小生成树的 Prim 算法和 Kruskal 算法
求单源最短路径的Dijkstra算法

